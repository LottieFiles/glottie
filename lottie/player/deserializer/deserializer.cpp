
#include "properties.h"
#include "shapes.h"
#include "layers.h"

string jsonString = "{'v':'5.5.7','fr':60,'ip':0,'op':480,'w':110,'h':110,'nm':'','ddd':0,'assets':[{'id':'comp_0','layers':[{'ddd':0,'ind':2,'ty':4,'nm':'2','td':1,'sr':1,'ks':{'o':{'a':0,'k':100,'ix':11},'r':{'a':0,'k':0,'ix':10},'p':{'a':0,'k':[375,667,0],'ix':2},'a':{'a':0,'k':[375,210,0],'ix':1},'s':{'a':0,'k':[100,100,100],'ix':6}},'ao':0,'shapes':[{'ty':'gr','it':[{'ind':0,'ty':'sh','ix':1,'ks':{'a':0,'k':{'i':[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],'o':[[0,0],[0,0],[0,0],[0,0],[0,0],[0,0],[0,0]],'v':[[-10.589,-56],[33.176,-56],[4.47,-16.941],[29.882,-16.941],[-30.824,56],[-10.589,4.639],[-33.177,4.639]],'c':true},'ix':2},'nm':' 1','mn':'ADBE Vector Shape - Group','hd':false},{'ty':'fl','c':{'a':0,'k':[0,0,0,1],'ix':4},'o':{'a':0,'k':100,'ix':5},'r':1,'bm':0,'nm':' 1','mn':'ADBE Vector Graphic - Fill','hd':false},{'ty':'tr','p':{'a':0,'k':[390.668,212.29],'ix':2},'a':{'a':0,'k':[0,0],'ix':1},'s':{'a':0,'k':[100,100],'ix':3},'r':{'a':0,'k':0,'ix':6},'o':{'a':0,'k':100,'ix':7},'sk':{'a':0,'k':0,'ix':4},'sa':{'a':0,'k':0,'ix':5},'nm':''}],'nm':' 1','np':2,'cix':2,'bm':0,'ix':1,'mn':'ADBE Vector Group','hd':false}],'ip':0,'op':478,'st':0,'bm':0},{'ddd':0,'ind':3,'ty':0,'nm':' 1  1','tt':1,'refId':'comp_1','sr':1,'ks':{'o':{'a':0,'k':100,'ix':11},'r':{'a':0,'k':0,'ix':10},'p':{'a':1,'k':[{'i':{'x':0.833,'y':0.833},'o':{'x':0.167,'y':0.167},'t':0,'s':[875,737,0],'to':[-180.333,0,0],'ti':[180.333,0,0]},{'t':478,'s':[-207,737,0]}],'ix':2},'a':{'a':0,'k':[750,667,0],'ix':1},'s':{'a':0,'k':[100,100,100],'ix':6}},'ao':0,'w':1500,'h':1334,'ip':0,'op':480,'st':0,'bm':0}]},{'id':'comp_1','layers':[{'ddd':0,'ind':1,'ty':0,'nm':' 1','refId':'comp_2','sr':1,'ks':{'o':{'a':0,'k':100,'ix':11},'r':{'a':0,'k':0,'ix':10},'p':{'a':1,'k':[{'i':{'x':0.667,'y':1},'o':{'x':0.333,'y':0},'t':0,'s':[751,628.5,0],'to':[2.5,-25.833,0],'ti':[-2.5,25.833,0]},{'i':{'x':0.667,'y':0.667},'o':{'x':0.333,'y':0.333},'t':120,'s':[766,473.5,0],'to':[0,0,0],'ti':[0,0,0]},{'i':{'x':0.667,'y':1},'o':{'x':0.333,'y':0},'t':240,'s':[766,473.5,0],'to':[-1.5,8,0],'ti':[1,-1.667,0]},{'i':{'x':0.667,'y':1},'o':{'x':0.333,'y':0},'t':300,'s':[757,521.5,0],'to':[-1,1.667,0],'ti':[-0.5,6.333,0]},{'i':{'x':0.667,'y':0.667},'o':{'x':0.333,'y':0.333},'t':360,'s':[760,483.5,0],'to':[0,0,0],'ti':[0,0,0]},{'i':{'x':0.667,'y':1},'o':{'x':0.333,'y':0},'t':420,'s':[760,483.5,0],'to':[-4.5,25.667,0],'ti':[4.5,-25.667,0]},{'t':476,'s':[733,637.5,0]}],'ix':2},'a':{'a':0,'k':[750,667,0],'ix':1},'s':{'a':0,'k':[100,100,100],'ix':6}},'ao':0,'w':1500,'h':1334,'ip':0,'op':480,'st':0,'bm':0}]},{'id':'comp_2','layers':[{'ddd':0,'ind':1,'ty':4,'nm':' 2','sr':1,'ks':{'o':{'a':0,'k':70,'ix':11},'r':{'a':0,'k':0,'ix':10},'p':{'a':0,'k':[753,660,0],'ix':2},'a':{'a':0,'k':[0,0,0],'ix':1},'s':{'a':0,'k':[100,100,100],'ix':6}},'ao':0,'shapes':[{'ty':'gr','it':[{'ind':0,'ty':'sh','ix':1,'ks':{'a':0,'k':{'i':[[57,24],[16,13],[54,-4],[50,59],[65,9],[45,45],[74,47],[19,-23],[63,25],[0,0],[0,0],[0,0],[0,0],[0,0],[25,58],[29,-8]],'o':[[-57,-24],[-16,-13],[-54,4],[-50,-59],[-65,-9],[-45,-45],[-74,-47],[-19,23],[-63,-25],[0,0],[0,0],[0,0],[0,0],[0,0],[-25,-58],[-29,8]],'v':[[425,56],[339,111],[240,83],[155,127],[-2,73],[-84,109],[-192,126],[-358,123],[-462,117],[-574,129],[-559,264],[164,280],[524,263],[569,232],[572,103],[492,100]],'c':true},'ix':2},'nm':' 1','mn':'ADBE Vector Shape - Group','hd':false},{'ty':'fl','c':{'a':0,'k':[0.03529400171,0.705881993911,0.580391977348,1],'ix':4},'o':{'a':0,'k':100,'ix':5},'r':1,'bm':0,'nm':' 1','mn':'ADBE Vector Graphic - Fill','hd':false},{'ty':'tr','p':{'a':0,'k':[0,0],'ix':2},'a':{'a':0,'k':[0,0],'ix':1},'s':{'a':0,'k':[100,100],'ix':3},'r':{'a':0,'k':0,'ix':6},'o':{'a':0,'k':100,'ix':7},'sk':{'a':0,'k':0,'ix':4},'sa':{'a':0,'k':0,'ix':5},'nm':''}],'nm':' 1','np':3,'cix':2,'bm':0,'ix':1,'mn':'ADBE Vector Group','hd':false}],'ip':0,'op':480,'st':0,'bm':0},{'ddd':0,'ind':2,'ty':4,'nm':' 1','sr':1,'ks':{'o':{'a':0,'k':70,'ix':11},'r':{'a':0,'k':0,'ix':10},'p':{'a':0,'k':[816,631,0],'ix':2},'a':{'a':0,'k':[0,0,0],'ix':1},'s':{'a':0,'k':[100,100,100],'ix':6}},'ao':0,'shapes':[{'ty':'gr','it':[{'ind':0,'ty':'sh','ix':1,'ks':{'a':0,'k':{'i':[[112,50],[28,0],[62,0],[48,68],[48,-18],[18,48],[34,-24],[18,50],[10,-2],[76,96],[0,0],[0,0],[0,0],[32,32],[52,-30]],'o':[[-60.295,-26.917],[-28,0],[-62,0],[-48,-68],[-48,18],[-18,-48],[-34,24],[-18,-50],[-10,2],[-76,-96],[0,0],[0,0],[0,0],[-32,-32],[-52,30]],'v':[[265,87],[187,125],[93,105],[7,93],[-109,145],[-191,137],[-315,129],[-365,119],[-421,101],[-483,119],[-601,155],[-603,239],[633,235],[617,115],[461,109]],'c':true},'ix':2},'nm':' 1','mn':'ADBE Vector Shape - Group','hd':false},{'ty':'fl','c':{'a':0,'k':[0.03529400171,0.705881993911,0.580391977348,1],'ix':4},'o':{'a':0,'k':100,'ix':5},'r':1,'bm':0,'nm':' 1','mn':'ADBE Vector Graphic - Fill','hd':false},{'ty':'tr','p':{'a':0,'k':[-2,30],'ix':2},'a':{'a':0,'k':[0,0],'ix':1},'s':{'a':0,'k':[100,100],'ix':3},'r':{'a':0,'k':0,'ix':6},'o':{'a':0,'k':100,'ix':7},'sk':{'a':0,'k':0,'ix':4},'sa':{'a':0,'k':0,'ix':5},'nm':''}],'nm':' 1','np':3,'cix':2,'bm':0,'ix':1,'mn':'ADBE Vector Group','hd':false}],'ip':0,'op':480,'st':0,'bm':0}]}],'layers':[{'ddd':0,'ind':1,'ty':0,'nm':' ','refId':'comp_0','sr':1,'ks':{'o':{'a':0,'k':100,'ix':11},'r':{'a':0,'k':0,'ix':10},'p':{'a':0,'k':[55,55,0],'ix':2},'a':{'a':0,'k':[375,667,0],'ix':1},'s':{'a':0,'k':[100,100,100],'ix':6}},'ao':0,'w':750,'h':1334,'ip':0,'op':480,'st':0,'bm':0}],'markers':[]}";

/*
string jsonString = "{'v':'5.5.8','fr':24,'ip':0,'op':63,'w':900,'h':900,'nm':'Comp 1','ddd':1,'assets':[],'layers':[{'ddd':1,'ind':1,'ty':4,'nm':'Shape Layer 4','parent':4,'sr':1,'ks':{'o':{'a':0,'k':100,'ix':11},'rx':{'a':0,'k':0,'ix':8},'ry':{'a':0,'k':270,'ix':9},'rz':{'a':0,'k':0,'ix':10},'or':{'a':0,'k':[0,0,0],'ix':7},'p':{'a':0,'k':[51,0,0],'ix':2},'a':{'a':0,'k':[51,0,0],'ix':1},'s':{'a':0,'k':[100,100,100],'ix':6}},'ao':0,'shapes':[{'ty':'gr','it':[{'ind':0,'ty':'sh','ix':1,'ks':{'a':0,'k':{'i':[[0,0],[0,0],[0,0]],'o':[[0,0],[0,0],[0,0]],'v':[[51.071,102.142],[-51.071,0],[51.071,-102.142]],'c':true},'ix':2},'nm':'Path 1','mn':'ADBE Vector Shape - Group','hd':false},{'ty':'fl','c':{'a':0,'k':[0.125490196078,0.639215686275,0.619607843137,1],'ix':4},'o':{'a':0,'k':100,'ix':5},'r':1,'bm':0,'nm':'Fill 1','mn':'ADBE Vector Graphic - Fill','hd':false},{'ty':'tr','p':{'a':0,'k':[0,0],'ix':2},'a':{'a':0,'k':[0,0],'ix':1},'s':{'a':0,'k':[100,100],'ix':3},'r':{'a':0,'k':0,'ix':6},'o':{'a':0,'k':100,'ix':7},'sk':{'a':0,'k':0,'ix':4},'sa':{'a':0,'k':0,'ix':5},'nm':'Transform'}],'nm':'Shape 1','np':3,'cix':2,'bm':0,'ix':1,'mn':'ADBE Vector Group','hd':false}],'ip':0,'op':658,'st':0,'bm':0},{'ddd':1,'ind':2,'ty':4,'nm':'Shape Layer 3','parent':4,'sr':1,'ks':{'o':{'a':0,'k':100,'ix':11},'rx':{'a':0,'k':0,'ix':8},'ry':{'a':0,'k':180,'ix':9},'rz':{'a':0,'k':0,'ix':10},'or':{'a':0,'k':[0,0,0],'ix':7},'p':{'a':0,'k':[51,0,0],'ix':2},'a':{'a':0,'k':[51,0,0],'ix':1},'s':{'a':0,'k':[100,100,100],'ix':6}},'ao':0,'shapes':[{'ty':'gr','it':[{'ind':0,'ty':'sh','ix':1,'ks':{'a':0,'k':{'i':[[0,0],[0,0],[0,0]],'o':[[0,0],[0,0],[0,0]],'v':[[51.071,102.142],[-51.071,0],[51.071,-102.142]],'c':true},'ix':2},'nm':'Path 1','mn':'ADBE Vector Shape - Group','hd':false},{'ty':'fl','c':{'a':0,'k':[0.882352941176,0.333333333333,0.329411764706,1],'ix':4},'o':{'a':0,'k':100,'ix':5},'r':1,'bm':0,'nm':'Fill 1','mn':'ADBE Vector Graphic - Fill','hd':false},{'ty':'tr','p':{'a':0,'k':[0,0],'ix':2},'a':{'a':0,'k':[0,0],'ix':1},'s':{'a':0,'k':[100,100],'ix':3},'r':{'a':0,'k':0,'ix':6},'o':{'a':0,'k':100,'ix':7},'sk':{'a':0,'k':0,'ix':4},'sa':{'a':0,'k':0,'ix':5},'nm':'Transform'}],'nm':'Shape 1','np':3,'cix':2,'bm':0,'ix':1,'mn':'ADBE Vector Group','hd':false}],'ip':0,'op':658,'st':0,'bm':0},{'ddd':1,'ind':3,'ty':4,'nm':'Shape Layer 2','parent':4,'sr':1,'ks':{'o':{'a':0,'k':100,'ix':11},'rx':{'a':0,'k':0,'ix':8},'ry':{'a':0,'k':90,'ix':9},'rz':{'a':0,'k':0,'ix':10},'or':{'a':0,'k':[0,0,0],'ix':7},'p':{'a':0,'k':[51,0,0],'ix':2},'a':{'a':0,'k':[51,0,0],'ix':1},'s':{'a':0,'k':[100,100,100],'ix':6}},'ao':0,'shapes':[{'ty':'gr','it':[{'ind':0,'ty':'sh','ix':1,'ks':{'a':0,'k':{'i':[[0,0],[0,0],[0,0]],'o':[[0,0],[0,0],[0,0]],'v':[[51.071,102.142],[-51.071,0],[51.071,-102.142]],'c':true},'ix':2},'nm':'Path 1','mn':'ADBE Vector Shape - Group','hd':false},{'ty':'fl','c':{'a':0,'k':[0.44099222819,0,1,1],'ix':4},'o':{'a':0,'k':100,'ix':5},'r':1,'bm':0,'nm':'Fill 1','mn':'ADBE Vector Graphic - Fill','hd':false},{'ty':'tr','p':{'a':0,'k':[0,0],'ix':2},'a':{'a':0,'k':[0,0],'ix':1},'s':{'a':0,'k':[100,100],'ix':3},'r':{'a':0,'k':0,'ix':6},'o':{'a':0,'k':100,'ix':7},'sk':{'a':0,'k':0,'ix':4},'sa':{'a':0,'k':0,'ix':5},'nm':'Transform'}],'nm':'Shape 1','np':3,'cix':2,'bm':0,'ix':1,'mn':'ADBE Vector Group','hd':false}],'ip':0,'op':658,'st':0,'bm':0},{'ddd':1,'ind':4,'ty':4,'nm':'Shape Layer 1','sr':1,'ks':{'o':{'a':0,'k':100,'ix':11},'rx':{'a':0,'k':312.125,'ix':8},'ry':{'a':1,'k':[{'i':{'x':[0.833],'y':[0.833]},'o':{'x':[0.167],'y':[0.167]},'t':0,'s':[0]},{'t':62,'s':[360]}],'ix':9},'rz':{'a':0,'k':138.742,'ix':10},'or':{'a':0,'k':[0,0,0],'ix':7},'p':{'a':0,'k':[491,406,0],'ix':2},'a':{'a':0,'k':[51,0,0],'ix':1},'s':{'a':0,'k':[249.792,249.792,249.792],'ix':6}},'ao':0,'shapes':[{'ty':'gr','it':[{'ind':0,'ty':'sh','ix':1,'ks':{'a':0,'k':{'i':[[0,0],[0,0],[0,0]],'o':[[0,0],[0,0],[0,0]],'v':[[51.071,102.142],[-51.071,0],[51.071,-102.142]],'c':true},'ix':2},'nm':'Path 1','mn':'ADBE Vector Shape - Group','hd':false},{'ty':'fl','c':{'a':0,'k':[0.639215686275,0.96862745098,0.709803921569,1],'ix':4},'o':{'a':0,'k':100,'ix':5},'r':1,'bm':0,'nm':'Fill 1','mn':'ADBE Vector Graphic - Fill','hd':false},{'ty':'tr','p':{'a':0,'k':[0,0],'ix':2},'a':{'a':0,'k':[0,0],'ix':1},'s':{'a':0,'k':[100,100],'ix':3},'r':{'a':0,'k':0,'ix':6},'o':{'a':0,'k':100,'ix':7},'sk':{'a':0,'k':0,'ix':4},'sa':{'a':0,'k':0,'ix':5},'nm':'Transform'}],'nm':'Shape 1','np':3,'cix':2,'bm':0,'ix':1,'mn':'ADBE Vector Group','hd':false}],'ip':0,'op':658,'st':0,'bm':0}],'markers':[]}";
*/

//// Helpers

struct transform {
};


//// Sources

struct ImageSource { 
	struct ImageSource* prev;
	struct ImageSource* next;

};

struct PrecompSource {
	struct PrecompSource* prev;
	struct PrecompSource* next;
	int id;
	struct Layer* layer;
};

struct CharSource {
};

struct PlayerSource {
};

struct FontSource {
};





struct Font {
	struct Font* prev;
	struct Font* next;
	struct FontSource* font;
};

struct Player {
	struct Player* prev;
	struct Player* next;
};

struct Chars {
	struct CharSource* charSource;

};





//enum States {NoState = 0, Animation = 1, Layers = 2, Assets = 3, Chars = 4, Players = 5, Fonts = 6, ks = 7, ao = 8, bm = 9, ddd = 10, maskProperties = 11, ef = 12, shapes = 13, it = 14, t = 15, a = 16, m = 17, r = 18, p = 19, s = 20, sk = 21, sa = 22, o = 23, sw =  24, sc = 25, fc = 26, fh = 27, fs = 28, fb = 29, maxa = 31, mine = 32, maxe = 33, bo = 34, start  = 35, end = 36, Offset = 37, g = 38};

enum Scopes {
	noscope = 0,
	object = 101,
	animation = 1,
	assets = 2,
	assets_layers = 403,
	assets_layers_shapes = 404,
	assets_layers_shapes_ty = 401,
	assets_layers_shapes_ks = 405,
	assets_layers_shapes_ks_k = 406,
	assets_layers_shapes_ks_k_e = 407,
	assets_layers_shapes_ks_k_s = 408,
	// 
	layers = 503,
	layers_shapes = 504,
	layers_shapes_ty = 501,
	layers_shapes_ks = 505,
	layers_shapes_ks_k = 506,
	layers_shapes_ks_k_e = 507,
	layers_shapes_ks_k_s = 508
	};

enum States {
	NoState = 1,
	Start = 2,
	ScopeOpen = 3,
	ScopeClose = 4,
	ScopeOpenInArray = 5,
	ScopeCloseInArray = 6,
	ArrayOpen = 7,
	ArrayClose = 8,
	KVSwitch = 9,
	KVReadOpen = 10,
	KVReading = 11,
	KVReadClose = 12,
	NewElement = 13,
	ScopeToBeRemoved = 14
	};

enum KeyValueState {Key, Value};

enum KeyValueState kvState = Key;

struct StateTrail {
	struct StateTrail* start = NULL;
	struct StateTrail* prev = NULL;
	struct StateTrail* next = NULL;
	enum States stateNow;
	bool keyEncountered = false;
} *theState;

struct ScopeTrail {
	struct scopeTrail* start = NULL;
	struct ScopeTrail* prev = NULL;
	struct ScopeTrail* next = NULL;

	struct KeyValueTrail* currentKeyValueTrail;
	struct StateTrail* currentState;
	enum Scopes scope;
} *theScope;

string lastValue;
string currentValue;
string lastRead;

string currentReadValue;
string currentReadKey;

bool readingArray = false;
bool wasReadingArray = false;

struct ArrayTrail {
	struct ArrayTrail* start = NULL;
	struct ArrayTrail* prev = NULL;
	struct ArrayTrail* next = NULL;
	bool isRoot;
	struct ScopeTrail scopeHere;
} *arrayNow; 

// currently unused function, referred from checkCharacter (commented out over there)
int determineCurrentScope() {
	if (theState->stateNow == ScopeOpen || theState->stateNow == ArrayOpen) {

		if (currentValue == "assets") {

			theScope->scope = assets;
		}
	}
	return 1;
}
/////////////////////////////////////////////////////////////////////////////

int addState(enum States statePassed) {
	struct StateTrail* tempState;
	tempState = new StateTrail;
	theState->next = tempState;
	tempState->prev = theState;
	tempState->start = theState->start;
	tempState->stateNow = statePassed;
	theState = tempState;

	return 1;
}

int removeState() {
	if (theState->prev != NULL) {
		struct StateTrail* tempState;
		tempState = theState;
		theState = theState->prev;
		theState->next = NULL;
		delete tempState;
	} else {
	}

	return 1;
}

int removeReadStates() {
	EM_ASM_({console.log("remove read state 1.0 " + $0);}, theState->stateNow);
	struct StateTrail* tempState;
	while (theState->prev != NULL && (theState->stateNow == KVReading || theState->stateNow == KVReadOpen)) {
		EM_ASM_({console.log("remove read state 1.0.1 " + $0);}, theState->prev);
		tempState = theState;
		theState = theState->prev;
		theState->next = NULL;
		delete tempState;
	}
	EM_ASM_({console.log("remove read state 1.1 " + $0);}, theState->stateNow);
	if (theState->prev == NULL && (theState->stateNow == KVReading || theState->stateNow == KVReadOpen)) {
		delete theState;
		theState = new StateTrail;
		theState->start = theState;
		theState->stateNow = NoState;
	}
	return 1;
}

int addScope(enum Scopes scopePassed) {

	struct ScopeTrail* tempScope;
	tempScope = new ScopeTrail;
	tempScope->prev = theScope;
	tempScope->next = NULL;
	theScope->next = tempScope;
	tempScope->start = theScope->start;
	theScope = tempScope;
	theScope->currentState = theState;

	/*
	struct ScopeTrail* tempScope;
	tempScope = new ScopeTrail;
	theScope->next = tempScope;
	tempScope->prev = theScope;
	theScope = tempScope;
	theScope->next = NULL;
	theScope->currentState = theState;
	theScope->start = theScope->prev->start;
	*/

	theScope->scope = scopePassed;

	return 1;
}

struct ScopeTrail* removeObjectsFromScope(struct ScopeTrail* passedScope) {
	struct ScopeTrail* tempScope;
	while (passedScope->prev != NULL && passedScope->scope == object) {
		tempScope = passedScope;
		passedScope = passedScope->prev;
		passedScope->next = NULL;
		delete tempScope;
	}
	return passedScope;
}

int removeScope() {
	//EM_ASM_({console.log($0);}, (int)theScope->scope);

	struct ScopeTrail* tempScope;
	//theScope = removeObjectsFromScope(tempScope);
	while (theScope->prev != NULL && theScope->scope == object) {
		if (theScope->currentKeyValueTrail != NULL) {
			deleteKeyValues(theScope->currentKeyValueTrail);
		}
		tempScope = theScope;
		theScope = theScope->prev;
		theScope->next = NULL;
		delete tempScope;
	}
	EM_ASM_({console.log("deleting " + $0);}, theScope->scope);
	if (theScope->currentKeyValueTrail != NULL) {
		deleteKeyValues(theScope->currentKeyValueTrail);
	}
	EM_ASM({console.log("deleted kvtrail");});

	if (theScope->prev != NULL) {
		tempScope->prev = NULL;
		theScope = theScope->prev;
		theScope->next = NULL;
		delete tempScope;
	} else {
		theScope->next = NULL;
	}
	EM_ASM_({console.log("left behind " + $0);}, theScope->scope);

	return 1;
}

int addArray() {
	struct ArrayTrail* tempArray;
	tempArray = new ArrayTrail;
	arrayNow->next = tempArray;
	tempArray->prev = arrayNow;
	arrayNow = arrayNow->next;
	arrayNow->start = arrayNow->prev->start;
	arrayNow->next = NULL;

	return 1;
}

int removeArray() {
	struct ArrayTrail* tempArray;
	tempArray = arrayNow;
	tempArray->prev = NULL;
	arrayNow = arrayNow->prev;
	arrayNow->next = NULL;
	delete tempArray;

	return 1;
}

#include "properties.cpp"
#include "layers.cpp"
#include "shapes.cpp"
#include "associate.cpp"

enum Scopes lastScopeBeforeObject() {
	struct ScopeTrail* tempScopeTrail;
	tempScopeTrail = theScope;
	while (tempScopeTrail->prev != NULL && tempScopeTrail->scope == object) {
		tempScopeTrail = tempScopeTrail->prev;
	}
	return tempScopeTrail->scope;
}

int checkScope() {
	EM_ASM_({console.log("-->found this " + $0);}, (int)lastScopeBeforeObject());
	switch (lastScopeBeforeObject()) {
		case noscope:
			theScope->scope = animation;

			//determineCurrentScope();
			break;
		case animation:
			if (currentReadKey == "assets") {
				EM_ASM({console.log('found assets');});
				addScope(assets); 
			} else if (currentReadKey == "layers") {
				addScope(layers);
			}
			break;
		case assets:
			if (currentReadKey == "layers") {
				EM_ASM({console.log('found layers');});
				addScope(assets_layers);
			}
			break;
		case assets_layers:
			if (currentReadKey == "shapes") {
				EM_ASM({console.log('found shapes');});
				addScope(assets_layers_shapes);
			}
			break;
		case assets_layers_shapes_ty: //LayersShapes shape item's type found
			
			break;
		case assets_layers_shapes:
			if (currentReadKey == "ks") {
				EM_ASM({console.log('found ks');});
				addScope(assets_layers_shapes_ks);
			} else if (currentReadKey == "ty") {
				addScope(assets_layers_shapes_ty);
			}
			break;
		case assets_layers_shapes_ks:
			if (currentReadKey == "k") {
				addScope(assets_layers_shapes_ks_k);
			}
			break;
		case assets_layers_shapes_ks_k:
			if (currentReadKey == "e") {
				addScope(assets_layers_shapes_ks_k_e);
			}
			if (currentReadKey == "s") {
				addScope(assets_layers_shapes_ks_k_s);
			}
			break;
		//
		case layers:
			if (currentReadKey == "shapes") {
				addScope(layers_shapes);
			}
			break;
		case layers_shapes_ty: //LayersShapes shape item's type found
			
			break;
		case layers_shapes:
			if (currentReadKey == "ks") {
				addScope(layers_shapes_ks);
			} else if (currentReadKey == "ty") {
				addScope(layers_shapes_ty);
			}
			break;
		case layers_shapes_ks:
			if (currentReadKey == "k") {
				addScope(layers_shapes_ks_k);
			}
			break;
		case layers_shapes_ks_k:
			if (currentReadKey == "e") {
				addScope(layers_shapes_ks_k_e);
			}
			if (currentReadKey == "s") {
				addScope(layers_shapes_ks_k_s);
			}
			break;
		default:
			addScope(object);
			break;
	}
	EM_ASM_({console.log("-->added this " + $0);}, (int)lastScopeBeforeObject());

	return 1;
}

int readingDone() {
		struct KeyValue* tempKeyValue;
		if (readingArray == true) {
			tempKeyValue = addKeyValue(theScope->currentKeyValueTrail->keyValue, currentReadKey, currentReadValue, true);
		} else {
			tempKeyValue = addKeyValue(theScope->currentKeyValueTrail->keyValue, currentReadKey, currentReadValue, false);
		}
		theScope->currentKeyValueTrail->keyValue = tempKeyValue->start;
	return 1;
}

bool isReadingDone() {
			EM_ASM({console.log("reading 100.1");});
			if (theState->stateNow == KVReading || theState->stateNow == KVReadOpen) {
				EM_ASM({console.log("reading 100.2");});
				if (kvState == Value) {
					currentReadValue = currentValue;
					EM_ASM({console.log("reading 100.2.1");});
					readingDone();
					EM_ASM({console.log("reading 100.2.2");});
					currentValue.clear();
					EM_ASM({console.log("reading 100.3");});
				} else {
					currentReadKey = currentValue;
					/*
					if (currentReadKey == "assets") {
						EM_ASM({console.log('found assets');});
					}
					if (currentReadKey == "shapes") {
						EM_ASM({console.log('found shapes');});
					}
					*/
					//EM_ASM_({console.log($0);}, (int)theScope->scope);
					currentValue.clear();
				}
				EM_ASM_({console.log("post-reading " + $0);}, theState->stateNow);
				return true;
			} else {
			}
	return false;
}

enum States lastStateBeforeReading() {
	struct StateTrail* tempState;
	tempState = theState;
	if (tempState == NULL) {
		return NoState;
	}

	if (tempState->stateNow != KVReadOpen && tempState->stateNow != KVReading) {
		return tempState->stateNow;
	}
	while (tempState->prev != NULL && (tempState->stateNow == KVReadOpen || tempState->stateNow == KVReading)) {
		tempState = tempState->prev;
	}
	return tempState->stateNow;
}

int checkCharacter(char& currentChar) {
	EM_ASM_({console.log("YAC +++++++++++++++++++++++++++++++++++++++> " + String.fromCharCode($0));}, currentChar);
	switch (currentChar) {
		case '{':
			EM_ASM_({console.log("OPENING object " + $0);}, theState->stateNow);
			//EM_ASM_({console.log($0);}, (int)theState->stateNow);
			if (isReadingDone()) {
				//readingDone();
				removeReadStates();
			}
			kvState = Key;
			readingArray = false;
			currentKeyValueTrail = theScope->currentKeyValueTrail;
			checkScope();
			newKeyValueTrail();
			theScope->currentKeyValueTrail = currentKeyValueTrail;
			if (theState->stateNow == ArrayOpen || theState->stateNow == ScopeOpenInArray || readingArray || theState->stateNow == ScopeToBeRemoved) {
				EM_ASM({console.log("opening object in array");});
				if (theState->keyEncountered) {
					prepareContainer(true);
				}
				addState(ScopeOpenInArray); //// ADD STATE
			} else {
				prepareContainer(false);
				addState(ScopeOpen); //// ADD STATE
			}

			//EM_ASM_({console.log($0);}, (int)theState->stateNow);
			EM_ASM_({console.log("OPENED object " + $0);}, theState->stateNow);
			break;
		case '}':
			EM_ASM_({console.log("CLOSING object " + $0);}, theState->stateNow);
			if (isReadingDone()) {
				//readingDone();
				removeReadStates();
			}
			EM_ASM_({console.log("CLOSING reading done " + $0);}, theState->stateNow);
			//EM_ASM_({console.log($0);}, (int)theState->stateNow);

			/*
			if (theState->prev->stateNow == ArrayOpen || theState->stateNow == ScopeOpenInArray || theState->stateNow == ScopeToBeRemoved) {
				readingArray = true;
			} else {
			}
			*/
			//removeKeyValueTrail();

			//if (theState->stateNow != ScopeOpenInArray && theState->stateNow != ScopeToBeRemoved) {
				associateKeyValues();
				EM_ASM_({console.log("CLOSING associated " + $0);}, theState->stateNow);
				removeScope();
				EM_ASM_({console.log("CLOSING removed scope " + $0);}, theState->stateNow);
				removeState();
				EM_ASM_({console.log("CLOSING removed state " + $0);}, theState->stateNow);
				currentKeyValueTrail = theScope->currentKeyValueTrail;
			/*} else {
				EM_ASM({console.log("still reading array");});
				readingArray = true;
				if (theState->stateNow == ScopeToBeRemoved) {
					removeState();
				}
				addState(ScopeToBeRemoved);
			}*/
			//EM_ASM_({console.log($0);}, (int)theState->stateNow);
			EM_ASM_({console.log("CLOSED object " + $0);}, theState->stateNow);
			break;
		case '[':
			EM_ASM_({console.log("[OPENING array " + $0);}, theState->stateNow);
			if (isReadingDone()) {
				//readingDone();
				removeReadStates();
			}
			readingArray = true;
			kvState = Value;
			//if (theState->stateNow == ArrayOpen) {
				addChildArray(theScope->currentKeyValueTrail->keyValue);
			//}
			addState(ArrayOpen); //// ADD STATE
			EM_ASM_({console.log("[OPENED array " + $0);}, theState->stateNow);
			break;
		case ']':
			EM_ASM_({console.log("[CLOSING array " + $0);}, theState->stateNow);
			//EM_ASM_({console.log($0);}, (int)theState->stateNow);
			if (isReadingDone()) {
				//readingDone();
				//readingDone();
				removeReadStates();
			}
			EM_ASM({console.log("[CLOSING reading completed");});
			kvState = Key;
			readingArray = false;
			EM_ASM({console.log("[CLOSING reading states removed");});
			gotoParentArray(currentKeyValue);
			EM_ASM({console.log("[CLOSING gone to parent array");});
			/*if (theState->stateNow == ScopeToBeRemoved) {
				EM_ASM({console.log("scope to be removed");});
				associateKeyValues();
				removeScope();
				removeState();
				currentKeyValueTrail = theScope->currentKeyValueTrail;
			}*/
			removeState();
			EM_ASM_({console.log("[CLOSED array " + $0);}, theState->stateNow);
			break;
		case ':':
			theState->keyEncountered = true;
			kvState = Value;
			break;
		case '\'':
			if (isReadingDone()) {
				//readingDone();
				//readingDone();
				removeReadStates();
			} else {
				//EM_ASM({console.log('read open');});
				addState(KVReadOpen); //// ADD STATE
				currentValue.clear();
			}

			break;
		case ',':
			EM_ASM({console.log("handling comma ");});
			//addState(NewElement);
			if (isReadingDone()) {
				//readingDone();
				//readingDone();
			}
			removeReadStates();
			EM_ASM({console.log("handling comma 1 " + $0);}, theState->stateNow);
			if (lastStateBeforeReading() == ArrayOpen) {
						//EM_ASM({console.log("reading values into an array ");});
				kvState = Value;
			} else {
				kvState = Key;
			}
			theState->keyEncountered = false;
			EM_ASM({console.log("done with comma ");});
			break;
		default:
			if (	currentChar != ' ' &&
				currentChar != '\f' &&
				currentChar != '\n' &&
				currentChar != '\r' &&
				currentChar != '\t' &&
				currentChar != '\v') {
				//if (theState->stateNow == KVReadOpen) {
					addState(KVReading); //// ADD STATE
				//}
			} else {
				if (theState->stateNow == KVReading) {
					addState(KVReading); //// ADD STATE
				}
			}
	}

	if (theState->stateNow == KVReading) {
		//currentValue = currentValue + currentChar;
		//currentValue.append((char *)currentChar);
		currentValue.append(1, currentChar);
		EM_ASM_({console.log(String.fromCharCode($0));}, currentChar);
	}

	/*///////////// DEBUG stuff
	if (theState->stateNow == KVReading) {
		EM_ASM_({
			console.log(String.fromCharCode($0));
		}, (int)currentChar);
	}
	//////////////////////// DEND */

	/*///////////// DEBUG stuff
	if (currentReadKey == "assets") {
		EM_ASM({
			console.log('found some assets');
		});
	}
	//////////////////////// DEND */

	return 1;
}


int deserialize() {
	//struct ScopeTrail* theScope;
	//struct StateTrail* theState;
	theScope = new ScopeTrail;
	theState = new StateTrail;
	theScope->prev = 0;
	theScope->next = 0;
	theScope->scope = noscope;
	theState->stateNow = Start;
	kvState = Key;

		EM_ASM({
			console.log('deserializing');
		});

	for(char& currentChar : jsonString) {

		checkCharacter(currentChar);
		
	}
	return 1;
}


